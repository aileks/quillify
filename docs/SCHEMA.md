# Quillify Database Schema

This document describes the complete database schema for Quillify, including tables, columns, relationships, and constraints.

## Overview

- **Database**: PostgreSQL
- **Schema Name**: `quillify`
- **ORM**: Drizzle ORM
- **Schema File**: `src/server/db/schema.ts`
- **Migrations**: `src/server/drizzle/`

All tables are organized under the `quillify` PostgreSQL schema to avoid conflicts with other schemas in the same database.

## Tables

### users

User accounts with authentication credentials.

**Columns:**

| Column            | Type                       | Constraints             | Description                                                |
| ----------------- | -------------------------- | ----------------------- | ---------------------------------------------------------- |
| `id`              | `text`                     | PRIMARY KEY, NOT NULL   | UUID v4 generated by `crypto.randomUUID()`                 |
| `name`            | `text`                     | NULL                    | User's display name (optional)                             |
| `email`           | `text`                     | UNIQUE, NULL            | User's email address (unique constraint)                   |
| `password`        | `text`                     | NULL                    | Bcrypt hashed password (nullable for future OAuth support) |
| `emailVerifiedAt` | `timestamp with time zone` | NULL                    | Timestamp when email was verified                          |
| `createdAt`       | `timestamp with time zone` | NOT NULL, DEFAULT now() | Record creation timestamp                                  |
| `updatedAt`       | `timestamp with time zone` | NOT NULL, DEFAULT now() | Record last update timestamp                               |

**Indexes:**

- Unique constraint on `email`

**Relationships:**

- One-to-many with `books`
- One-to-many with `password_reset_tokens`

**Notes:**

- Password is nullable to support future OAuth providers that don't require passwords
- Email verification is optional (nullable `emailVerifiedAt`)
- All timestamps use timezone-aware `timestamp with time zone` type

### books

Book entries linked to users in their personal library.

**Columns:**

| Column          | Type                       | Constraints             | Description                                |
| --------------- | -------------------------- | ----------------------- | ------------------------------------------ |
| `id`            | `text`                     | PRIMARY KEY, NOT NULL   | UUID v4 generated by `crypto.randomUUID()` |
| `userId`        | `text`                     | NOT NULL, FOREIGN KEY   | References `users.id` (CASCADE on delete)  |
| `title`         | `text`                     | NOT NULL                | Book title                                 |
| `author`        | `text`                     | NOT NULL                | Book author name                           |
| `numberOfPages` | `integer`                  | NOT NULL                | Total number of pages (must be > 0)        |
| `genre`         | `text`                     | DEFAULT 'Other'         | Book genre/category (defaults to 'Other')  |
| `publishYear`   | `integer`                  | NOT NULL                | Year the book was published (must be > 0)  |
| `isRead`        | `boolean`                  | NOT NULL, DEFAULT false | Whether the book has been read             |
| `createdAt`     | `timestamp with time zone` | NOT NULL, DEFAULT now() | Record creation timestamp                  |
| `updatedAt`     | `timestamp with time zone` | NOT NULL, DEFAULT now() | Record last update timestamp               |

**Indexes:**

- Foreign key index on `userId` (automatically created by PostgreSQL)

**Foreign Keys:**

- `books.userId` → `users.id` (ON DELETE CASCADE, ON UPDATE NO ACTION)

### password_reset_tokens

Stores password reset tokens for the forgot password flow.

**Columns:**

| Column      | Type                       | Constraints             | Description                                       |
| ----------- | -------------------------- | ----------------------- | ------------------------------------------------- |
| `id`        | `text`                     | PRIMARY KEY, NOT NULL   | UUID v4 generated by `crypto.randomUUID()`        |
| `userId`    | `text`                     | NOT NULL, FOREIGN KEY   | References `users.id` (CASCADE on delete)         |
| `token`     | `text`                     | NOT NULL, UNIQUE        | Secure random token (64 hex characters)           |
| `expiresAt` | `timestamp with time zone` | NOT NULL                | Token expiration timestamp (30 min from creation) |
| `createdAt` | `timestamp with time zone` | NOT NULL, DEFAULT now() | Record creation timestamp                         |

**Indexes:**

- Unique constraint on `token`
- Foreign key index on `userId` (automatically created by PostgreSQL)

**Foreign Keys:**

- `password_reset_tokens.userId` → `users.id` (ON DELETE CASCADE, ON UPDATE NO ACTION)

**Notes:**

- Tokens expire after 30 minutes
- Rate limited to 3 tokens per email per hour at the application level
- Expired tokens are cleaned up daily via cron job and on-demand during validation
- Token is deleted after successful password reset

## Schema Definition

The schema is defined using Drizzle ORM in `src/server/db/schema.ts`:

```typescript
import { text, integer, boolean, timestamp, pgSchema } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

const quillify = pgSchema('quillify');

export const users = quillify.table('users', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text('name'),
  email: text('email').unique(),
  password: text('password'),
  emailVerifiedAt: timestamp('emailVerifiedAt', { mode: 'date', withTimezone: true }),
  createdAt: timestamp('createdAt', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updatedAt', { withTimezone: true }).defaultNow().notNull(),
});

export const books = quillify.table('books', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userId: text('userId')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  title: text('title').notNull(),
  author: text('author').notNull(),
  numberOfPages: integer('numberOfPages').notNull(),
  genre: text('genre').default('Other'),
  publishYear: integer('publishYear').notNull(),
  isRead: boolean('isRead').notNull().default(false),
  createdAt: timestamp('createdAt', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updatedAt', { withTimezone: true }).defaultNow().notNull(),
});

export const passwordResetTokens = quillify.table('password_reset_tokens', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  userId: text('userId')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  token: text('token').notNull().unique(),
  expiresAt: timestamp('expiresAt', { mode: 'date', withTimezone: true }).notNull(),
  createdAt: timestamp('createdAt', { withTimezone: true }).defaultNow().notNull(),
});
```

## Migrations

Schema changes are managed through Drizzle Kit migrations:

- **Migration Files**: `src/server/drizzle/XXXX_*.sql`
- **Configuration**: `drizzle.config.ts`
- **Schema Filter**: Only `quillify` schema tables are managed

## TypeScript Types

Drizzle automatically infers TypeScript types from the schema:

```typescript
import { users, books, passwordResetTokens } from '@/server/db/schema';

// Infer select type (for queries)
type User = typeof users.$inferSelect;
type Book = typeof books.$inferSelect;
type PasswordResetToken = typeof passwordResetTokens.$inferSelect;

// Infer insert type (for mutations)
type NewUser = typeof users.$inferInsert;
type NewBook = typeof books.$inferInsert;
type NewPasswordResetToken = typeof passwordResetTokens.$inferInsert;
```

## Constraints and Validation

### Application-Level Validation

While the database schema provides basic constraints, additional validation is enforced at the application level via Zod schemas in tRPC procedures:

- **Email**: Must be valid email format
- **Password**: Minimum 8 characters, must contain uppercase, lowercase, and number
- **Name**: Minimum 2 characters
- **Book Title/Author**: Minimum 1 character
- **NumberOfPages**: Must be positive integer
- **PublishYear**: Must be positive integer of 1500 or greater

## Notes

### Authentication Tables

Quillify uses _JWT-based sessions_, so there are no `sessions` or `accounts` tables.

## Related Documentation

- [API.md](./API.md) - API architecture and tRPC setup
- [ROUTES.md](./ROUTES.md) - Complete list of tRPC procedures and endpoints
- [README.md](../README.md) - Project overview and setup instructions
